#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://github.com/Linuxfabrik/monitoring-plugins/blob/main/CONTRIBUTING.rst

"""See the check's README for more details.
"""

import warnings  # pylint: disable=C0413

warnings.filterwarnings('ignore', category=UserWarning, module='pymysql')

import argparse  # pylint: disable=C0413
import os  # pylint: disable=C0413
import re  # pylint: disable=C0413
import socket  # pylint: disable=C0413
import sys  # pylint: disable=C0413

import lib.base  # pylint: disable=C0413
import lib.disk  # pylint: disable=C0413
import lib.distro  # pylint: disable=C0413
import lib.dmidecode  # pylint: disable=C0413
import lib.human  # pylint: disable=C0413
import lib.net  # pylint: disable=C0413
import lib.shell  # pylint: disable=C0413
import lib.txt  # pylint: disable=C0413
import lib.version  # pylint: disable=C0413
from lib.globals import STATE_OK, STATE_UNKNOWN  # pylint: disable=C0413

try:
    import psutil  # pylint: disable=C0413
    HAVE_PSUTIL = True
except ImportError:
    HAVE_PSUTIL = False


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2024041001'

DESCRIPTION = 'Reports a quick overview about the host dimensions and ยง software.'

DEFAULT_INSECURE = False
DEFAULT_NO_PROXY = False
DEFAULT_PUBLIC_IP_URL = None
DEFAULT_TIMEOUT = 2


def parse_args():
    """Parse command line arguments using argparse.
    """
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    parser.add_argument(
        '--insecure',
        help='This option explicitly allows to perform "insecure" SSL connections. '
             'Default: %(default)s',
        dest='INSECURE',
        action='store_true',
        default=DEFAULT_INSECURE,
    )

    parser.add_argument(
        '--no-proxy',
        help='Do not use a proxy. '
             'Default: %(default)s',
        dest='NO_PROXY',
        action='store_true',
        default=DEFAULT_NO_PROXY,
    )

    parser.add_argument(
        '--public-ip-url',
        help='If you want this check to return the public IP address, specify one ore more '
             'comma-separated URLs to "what is my ip" online services. '
             'For example: '
             '"https://ipv4.icanhazip.com,https://ipecho.net/plain,https://ipinfo.io/ip" '
             '(these examples are located in the United States). '
             'Default: %(default)s',
        dest='PUBLIC_IP_URL',
        default=DEFAULT_PUBLIC_IP_URL,
    )

    parser.add_argument(
        '--tags',
        help='Guess a list of tags to apply in Icinga Director (Linuxfabrik Basket Config).',
        dest='TAGS',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--timeout',
        help='Network timeout in seconds. '
             'Default: %(default)s (seconds)',
        dest='TIMEOUT',
        type=int,
        default=DEFAULT_TIMEOUT,
    )

    return parser.parse_args()


def get_birthday():
    """Using various methods to determine install date.
    """
    # Using stat
    cmd = 'stat / | grep "Birth" | sed "s/Birth: //g" | cut -b 2-11'
    success, result = lib.shell.shell_exec(cmd)
    birthday, _, _ = result
    if not success or birthday == '-':
        # nothing found so far, try more - but not all of those are very accurate
        if os.path.isfile('/usr/bin/pacman'):
            # Arch Linux, and Arch based distros using pacman
            cmd = 'head -n 1 $PACMAN_LOG | cut -b 2-11'
        elif os.path.isfile('/usr/bin/emerge'):
            # Gentoo Linux and Gentoo based distros using portage
            cmd = 'head -n 1 $PORTAGE_LOG | cut -b 31-43'
        elif os.path.isfile('/usr/bin/rpm'):
            # Fedora, RedHat, and RPM based distros
            cmd = 'rpm -qi basesystem | grep "Install Date" | sed "s/Install Date: //g"'
        success, result = lib.shell.shell_exec(cmd)
        if success:
            birthday, _, _ = result
    if birthday and birthday != '-':
        return 'born {}. '.format(birthday.strip())
    return ''


def get_boot_mode():
    return 'UEFI boot, ' if os.path.isdir('/sys/firmware/efi') else 'BIOS boot, '


def get_crontab():
    """Returns all crontab items.
    """
    cmd = r"grep --dereference-recursive --no-filename --invert-match '\s*#' /etc/crontab /etc/cron.d/ /etc/anacrontab /var/spool/cron" # pylint: disable=C0301
    success, result = lib.shell.shell_exec(cmd)
    if not success:
        return ''
    stdout, _, _ = result
    output = ''
    line_regex = re.compile(r'\S+=')
    for line in stdout.splitlines():
        line = line.strip()
        if len(line) > 0 and re.match(line_regex, line) is None:
            output = '{}{}\n'.format(output, line)
    if output:
        output = 'crontab:\n{}\n'.format(output)
    return output


def get_disks():
    """Returns system disks tuple "text, count": `'Disk nvme0n1 1.8T', 1`
    """
    success, result = lib.shell.shell_exec(
        'lsblk --nodeps --output NAME,SIZE --noheadings --include 8,252,259'
    )
    if not success:
        return '', 0
    stdout, _, _ = result
    output = []
    for disk in stdout.strip().splitlines():
        # zRAM devices can appear in the output of lsblk, but we cannot do anything useful with them
        if disk.startswith('zram'):
            continue
        output.append(re.sub('\\s+', ' ', disk))
    return '{} {}, '.format(
        lib.txt.pluralize('Disk', len(output)),
        ', '.join(output),
    ), len(output)


def get_hw_info():
    result = lib.dmidecode.get_data()
    output = ''
    for _, value in result.items():
        if value['dminame'] == 'Base Board Information':
            output += '* Base Board: Type {} {} {}, SerNo {}, Ver {}\n'.format(
                value.get('Type', 'N/A'),
                value.get('Manufacturer', 'N/A'),
                value.get('Product Name', 'N/A'),
                value.get('Serial Number', 'N/A'),
                value.get('Version', 'N/A'),
            )
        if value['dminame'] == 'BIOS Information':
            output += '* BIOS: {}, Ver {} (released {}), ROM {}\n'.format(
                value.get('Vendor', 'N/A'),
                value.get('Version', 'N/A'),
                value.get('Release Date', 'N/A'),
                value.get('ROM Size', 'N/A'),
            )
        if value['dminame'] == 'Chassis Information':
            output += '* Chassis: {}, Type {}, SKU {}, SerNo {}\n'.format(
                value.get('Manufacturer', 'N/A'),
                value.get('Type', 'N/A'),
                value.get('SKU', 'N/A'),
                value.get('Serial Number', 'N/A'),
            )
            output += '  States: boot-up={}, pwr-supply={}, thermal={}, security={}\n'.format(
                value.get('Boot-up State', 'N/A'),
                value.get('Power Supply State', 'N/A'),
                value.get('Thermal State', 'N/A'),
                value.get('Security Status', 'N/A'),
            )
        if value['dminame'] == 'Processor Information':
            output += '* Proc: {}, Ver {},\n'.format(
                value.get('Manufacturer', 'N/A'),
                value.get('Version', 'N/A'),
            )
            output += '  Speed {}/{} max., {}/{} Cores enabled, {} {}, Voltage {}\n'.format(
                value.get('Current Speed', 'N/A'),
                value.get('Max Speed', 'N/A'),
                value.get('Core Enabled', 'N/A'),
                value.get('Core Count', 'N/A'),
                value.get('Thread Count', 'N/A'),
                lib.txt.pluralize('Thread', value.get('Thread Count', 0)),
                value.get('Voltage', 'N/A'),
            )
        if value['dminame'] == 'System Boot Information':
            output += '* System Boot: {}\n'.format(
                value.get('Status', 'N/A'),
            )
        if value['dminame'] == 'System Information':
            output += '* SysInfo: {} {}, SerNo {}, SKU {}, Wake-up Type "{}",\n'.format(
                value.get('Manufacturer', 'N/A'),
                value.get('Product Name', 'N/A'),
                value.get('Serial Number', 'N/A'),
                value.get('SKU', 'N/A'),
                value.get('Wake-up Type', 'N/A'),
            )
            output += '  UUID {}\n'.format(
                value.get('UUID', 'N/A'),
            )
    if output:
        return 'Hardware Info:\n{}\n'.format(output)
    return output


def get_interfaces():
    output = ''
    try:
        for name, interface in sorted(psutil.net_if_addrs().items()):
            if name == 'lo':
                continue
            for addr in interface:
                if addr.family == lib.net.AF_INET:
                    output += '* {} {}/{}\n'.format(
                        name,
                        addr.address,
                        lib.net.ip_to_cidr(addr.netmask),
                    )
    except:
        pass
    if output:
        return 'Interfaces (IPv4):\n{}\n'.format(output)
    return output


def get_listening_ports():
    ports = {}
    output = []
    try:
        nc = psutil.net_connections('inet')
        for c in nc:
            if c.status != psutil.CONN_LISTEN and c.status != psutil.CONN_NONE:
                continue
            if c.type == socket.SOCK_STREAM:
                proto = 'tcp'
            elif c.type == socket.SOCK_DGRAM:
                proto = 'udp'
            else:
                continue
            if c.family == socket.AF_INET:
                proto += '4'
            else:
                proto += '6'
            ip, port = c.laddr
            ports['{}#{}#{}'.format(ip, port, proto)] = {
                'proto': proto,
                'ip': '[{}]'.format(ip) if c.family == socket.AF_INET6 and not ip.startswith('[') and not ip.endswith(']') else ip, # pylint: disable=C0301
                'port': port,
            }
        for _, value in ports.items():
            output.append(value)
        output = sorted(output, key=lambda d: (d['port'], d['proto'], d['ip']))
    except:
        pass
    if output:
        msg = 'Listening TCP/UDP Ports (ordered by port, proto, ip):\n'
        for p in output:
            msg += '* {}:{}/{}\n'.format(p['ip'], p['port'], p['proto'])
        msg += '\n'
        return msg
    return ''


def get_nondefault_software():
    success, result = lib.shell.shell_exec(
        'dnf repoquery --userinstalled --queryformat "%{name};%{version};%{from_repo};%{installtime}"' # pylint: disable=C0301
    )
    if not success:
        return []
    stdout, _, _ = result
    table_data = []
    header = ['name', 'version', 'from_repo', 'installtime']
    for line in stdout.splitlines():
        data = dict(zip(header, line.split(';')))
        table_data.append(data)
    output = lib.base.get_table(
        table_data,
        header,
        header=header,
    )
    if output:
        return 'Non-default Software (ordered by name):\n{}\n'.format(output)
    return ''


def get_nondefault_users():
    default_linux_users = [
        '_apt',
        '_rpc',
        'abrt',
        'adm',
        'avahi',
        'backup',
        'bin',
        'chrony',
        'colord',
        'daemon',
        'dbus',
        'ftp',
        'games',
        'gnats',
        'halt',
        'irc',
        'list',
        'lp',
        'mail',
        'man',
        'messagebus',
        'news',
        'nobody',
        'operator',
        'pi',
        'polkitd',
        'proxy',
        'pulse',
        'rngd',
        'root',
        'rpc',
        'rpcuser',
        'shutdown',
        'sshd',
        'sssd',
        'sync',
        'sys',
        'systemd-coredump',
        'systemd-network',
        'systemd-oom',
        'systemd-resolve',
        'systemd-timesync',
        'tcpdump',
        'tss',
        'unbound',
        'user',
        'uucp',
    ]
    passwd = lib.base.coe(lib.disk.read_file('/etc/passwd'))
    table_data = []
    header = ['user', 'pw', 'uid', 'gid', 'comment', 'home_dir', 'user_shell']
    for line in passwd.splitlines():
        data = dict(zip(header, line.split(':')))
        if data['user'] not in default_linux_users:
            table_data.append(data)

    output = lib.base.get_table(
        table_data,
        header,
        header=header,
        sort_by_key='user',
    )
    if output:
        return 'Non-default Users:\n{}\n'.format(output)
    return ''


def get_public_ip(args):
    success, pub_ip = lib.net.get_public_ip(
        args.PUBLIC_IP_URL,
        insecure=args.INSECURE,
        no_proxy=args.NO_PROXY,
        timeout=args.TIMEOUT,
    )
    if success:
        return 'Public IP {}, '.format(pub_ip)
    return ''


def get_sys_dimensions():
    """get some very basic system statistics
    """
    sys_dimensions = {}
    try:
        sys_dimensions['cpu'] = psutil.cpu_count(logical=True)
        sys_dimensions['ram'] = psutil.virtual_memory().total
    except:
        pass
    return sys_dimensions


def get_systemd_default_target():
    cmd = 'systemctl get-default'
    success, result = lib.shell.shell_exec(cmd)
    if not success:
        return ''
    stdout, stderr, retc = result
    if stderr or retc != 0:
        return ''
    return 'systemctl get-default:\n* {}\n\n'.format(stdout.strip())


def get_systemd_timers():
    # using `--output=json` sadly does not work with older systemd versions
    # (eg systemd 219 on CentOS 7 or systemd 239 on RHEL 8), therefore we have to parse
    # the human output.
    # in order to list for a different user (`--user`), we would need to sudo to that user
    # first - we will skip that for now
    success, result = lib.shell.shell_exec('systemctl list-timers')
    if not success:
        return ''
    stdout, stderr, retc = result
    if stderr or retc != 0:
        return ''

    table_data = []
    next_pos = None
    left_pos = None
    unit_pos = None
    activates_pos = None
    for line in stdout.splitlines():
        if next_pos is None:
            # clutters a little bit on modern systemd (Fedora) because of right-aligned LEFT
            next_pos = line.find('NEXT')
            left_pos = line.find('LEFT')
            unit_pos = line.find('UNIT')
            activates_pos = line.find('ACTIVATES')
        if '.timer' in line:
            table_data.append({
                'unit': line[unit_pos:activates_pos].strip(),
                'activates': line[activates_pos:].strip(),
                'next': line[next_pos:left_pos].strip(),
            })

    output = lib.base.get_table(
        table_data,
        ['unit', 'activates', 'next'],
        header=['unit', 'activates', 'next'],
        sort_by_key='unit',
    )
    if output:
        return 'systemctl list-timers:\n{}\n'.format(output)
    return ''


def get_systemd_units(cmd):
    # using `--output=json` sadly does not work with older systemd versions
    # (eg systemd 219 on CentOS 7 or systemd 239 on RHEL 8), therefore we have to parse
    # the human output.
    # in order to list for a different user (`--user`), we would need to sudo to that user
    # first - we will skip that for now
    success, result = lib.shell.shell_exec(cmd)
    if not success:
        return ''
    stdout, stderr, retc = result
    if stderr or retc != 0:
        return ''
    if not stdout:
        return ''

    output = '{}:\n'.format(cmd.replace(' --no-legend', ''))
    for line in stdout.splitlines():
        output += '* {}\n'.format(line.split()[0])
    return output + '\n'


def get_tuned_active_profile():
    """ Return current active tuned profile (if any).
    """
    output = run_cmd('tuned-adm active')
    if output:
        return 'tuned profile "{}", '.format(run_regex(output, r': (.*)').strip().replace('* ', ''))
    return ''


def get_virt_info():
    # alternative would be `/usr/sbin/virt-what` (POSIX shell script)
    success, result = lib.shell.shell_exec('systemd-detect-virt')
    if success:
        stdout, _, _ = result
        return stdout.strip()
    return 'Unknown'


def run_cmd(cmd, ignore_output=False):
    """Run a command and return its output. Returns stderr if cmd prints its standard output there.
    If ignore_output is set to True, returns True. Returns False if cmd is not found.
    """
    env = os.environ.copy()
    env['LC_ALL'] = 'C'
    env['PATH'] += ':/usr/local/bin:/usr/local/sbin'
    success, result = lib.shell.shell_exec(cmd, env=env)
    if not success:
        return False
    stdout, stderr, retc = result
    if retc != 0:
        # for example if using `command -v loolwsd`
        return False
    if ignore_output:
        return True
    if stdout == '' and stderr != '':
        # https://stackoverflow.com/questions/26028416/why-does-python-print-version-info-to-stderr
        # https://stackoverflow.com/questions/13483443/why-does-java-version-go-to-stderr
        stdout = stderr
    try:
        return stdout.strip().splitlines()[0].strip()
    except IndexError:
        return True


def run_regex(haystack, regex, group=1):
    """Apply a regex to a haystack, assume first match group, otherwise let us choose which one.
    """
    re_search = re.search(regex, haystack)
    if re_search:
        return re_search.group(group).strip()
    return ''


def main():
    """The main function. Hier spielt die Musik.
    """

    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    # init some vars
    perfdata = ''
    tags = ''

    # only tags wanted, so it's ok to stop here
    if args.TAGS:
        lib.base.oao(tags, STATE_OK)

    # build the message

    # first header line ----------------------------------------------------------------------------
    msg = '{}: '.format(socket.gethostname())

    os_info = lib.version.get_os_info()
    if os_info:
        msg += '{} '.format(os_info)
    msg += 'Kernel {} '.format(run_cmd('uname -r'))

    virt = get_virt_info()
    if virt == 'none':
        msg += 'on Bare-Metal, '
    else:
        msg += 'virtualized on {}, '.format(virt)

    success, firmware_device_model = lib.disk.read_file('/sys/firmware/devicetree/base/model')
    if not success:
        firmware_device_model = ''
    if firmware_device_model:
        msg += '{}, '.format(firmware_device_model)

    dmi = lib.dmidecode.get_data()
    sys_dimensions = get_sys_dimensions()
    if dmi:
        msg += '{} {}, '.format(lib.dmidecode.manufacturer(dmi), lib.dmidecode.model(dmi))
        msg += 'Firmware: {}, '.format(lib.dmidecode.firmware(dmi))
        msg += 'SerNo: {}, '.format(lib.dmidecode.serno(dmi))
        msg += 'Proc: {}, '.format(lib.dmidecode.cpu_type(dmi))
        msg += '#Cores: {}, '.format(lib.dmidecode.cpu_cores_enabled(dmi))
        msg += '#Threads: {}, '.format(lib.dmidecode.cpu_threads(dmi))
        msg += 'Current Speed: {} MHz, '.format(lib.dmidecode.cpu_speed(dmi))
        msg += '{} RAM, '.format(lib.human.bytes2human(lib.dmidecode.ram(dmi)))
    elif sys_dimensions:
        msg += '{} {}, {} RAM, '.format(
            sys_dimensions['cpu'],
            lib.txt.pluralize('CPU', sys_dimensions['cpu']),
            lib.human.bytes2human(sys_dimensions['ram'])
        )
    else:
        msg += 'sys dimensions n/a (consider installing psutil), '

    disk_msg, disk_count = get_disks()
    msg += disk_msg
    msg += get_boot_mode()
    msg += get_tuned_active_profile()
    msg += get_public_ip(args)
    msg += get_birthday()
    msg += 'About-me v{}\n\n'.format(__version__)


    # multi-line content - print further lines -----------------------------------------------------
    msg += get_hw_info()
    msg += get_interfaces()
    msg += get_listening_ports()
    msg += get_nondefault_software()
    msg += get_nondefault_users()
    msg += get_systemd_default_target()
    msg += get_systemd_units(
        'systemctl list-unit-files --type=service --state=enabled --no-legend',
    )
    msg += get_systemd_units(
        'systemctl list-unit-files --type=mount --state=static --state=generated --no-legend',
    )
    msg += get_systemd_units(
        'systemctl list-unit-files --type=automount --state=enabled --state=static --no-legend',
    )
    msg += get_systemd_timers()
    msg += get_crontab()

    # perfdata
    if os_info:
        re_search = re.search(r'[\d\.]+', os_info)
        if re_search:
            perfdata += lib.base.get_perfdata('osversion', re_search.group(0).replace('.', ''), None, None, None, None, None) # pylint: disable=C0301
    if dmi:
        perfdata += lib.base.get_perfdata('cpu_cores_enabled', lib.dmidecode.cpu_cores_enabled(dmi), None, None, None, 0, None)
        perfdata += lib.base.get_perfdata('cpu_threads', lib.dmidecode.cpu_threads(dmi), None, None, None, 0, None)
        perfdata += lib.base.get_perfdata('cpu_speed', lib.dmidecode.cpu_speed(dmi), None, None, None, 0, None)
        perfdata += lib.base.get_perfdata('ram', lib.dmidecode.ram(dmi), 'B', None, None, 0, None)
    elif sys_dimensions:
        perfdata += lib.base.get_perfdata('cpu', sys_dimensions['cpu'], None, None, None, 0, None)
        perfdata += lib.base.get_perfdata('ram', sys_dimensions['ram'], 'B', None, None, 0, None)
    perfdata += lib.base.get_perfdata('disks', disk_count, None, None, None, 0, None)

    # over and out
    lib.base.oao(msg, STATE_OK, perfdata)


if __name__ == '__main__':
    try:
        main()
    except Exception:   # pylint: disable=W0703
        lib.base.cu()
