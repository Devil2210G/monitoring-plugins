#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://github.com/Linuxfabrik/monitoring-plugins/blob/main/CONTRIBUTING.rst

"""See the check's README for more details.
"""

import warnings  # pylint: disable=C0413

warnings.filterwarnings('ignore', category=UserWarning, module='pymysql')

import argparse  # pylint: disable=C0413
import os  # pylint: disable=C0413
import re  # pylint: disable=C0413
import socket  # pylint: disable=C0413
import sys  # pylint: disable=C0413

import lib.base  # pylint: disable=C0413
import lib.disk  # pylint: disable=C0413
import lib.distro  # pylint: disable=C0413
import lib.dmidecode  # pylint: disable=C0413
import lib.human  # pylint: disable=C0413
import lib.net  # pylint: disable=C0413
import lib.shell  # pylint: disable=C0413
import lib.txt  # pylint: disable=C0413
import lib.version  # pylint: disable=C0413
from lib.globals import STATE_OK, STATE_UNKNOWN  # pylint: disable=C0413

try:
    import psutil  # pylint: disable=C0413
    HAVE_PSUTIL = True
except ImportError:
    HAVE_PSUTIL = False


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2024041101'

DESCRIPTION = 'Provides a quick overview of host dimensions and software.'

DEFAULT_INSECURE = False
DEFAULT_NO_PROXY = False
DEFAULT_PUBLIC_IP_URL = None
DEFAULT_TIMEOUT = 2


def parse_args():
    """Parse command line arguments using argparse.
    """
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    parser.add_argument(
        '--insecure',
        help='This option explicitly allows to perform "insecure" SSL connections. '
             'Default: %(default)s',
        dest='INSECURE',
        action='store_true',
        default=DEFAULT_INSECURE,
    )

    parser.add_argument(
        '--no-proxy',
        help='Do not use a proxy. '
             'Default: %(default)s',
        dest='NO_PROXY',
        action='store_true',
        default=DEFAULT_NO_PROXY,
    )

    parser.add_argument(
        '--public-ip-url',
        help='If you want this check to return the public IP address, specify one ore more '
             'comma-separated URLs to "what is my ip" online services. '
             'For example: '
             '"https://ipv4.icanhazip.com,https://ipecho.net/plain,https://ipinfo.io/ip" '
             '(these examples are located in the United States). '
             'Default: %(default)s',
        dest='PUBLIC_IP_URL',
        default=DEFAULT_PUBLIC_IP_URL,
    )

    parser.add_argument(
        '--tags',
        help='Guess a list of tags to apply in Icinga Director (Linuxfabrik Basket Config).',
        dest='TAGS',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--timeout',
        help='Network timeout in seconds. '
             'Default: %(default)s (seconds)',
        dest='TIMEOUT',
        type=int,
        default=DEFAULT_TIMEOUT,
    )

    return parser.parse_args()


def get_birthday():
    """Using various methods to determine install date.
    """
    # Using stat
    success, result = lib.shell.shell_exec(
        'stat / | grep "Birth" | sed "s/Birth: //g" | cut -b 2-11',
        shell=True,
    )
    birthday, _, _ = result
    birthday = birthday.strip()
    if birthday == '-':
        birthday = ''
        # nothing found so far, try more - but not all of those are very accurate
        if os.path.isfile('/usr/bin/pacman'):
            # Arch Linux, and Arch based distros using pacman
            cmd = 'head -n 1 $PACMAN_LOG | cut -b 2-11'
        elif os.path.isfile('/usr/bin/emerge'):
            # Gentoo Linux and Gentoo based distros using portage
            cmd = 'head -n 1 $PORTAGE_LOG | cut -b 31-43'
        elif os.path.isfile('/usr/bin/rpm'):
            # Fedora, RedHat, and RPM based distros
            cmd = 'rpm -qi basesystem | grep "Install Date" | sed "s/Install Date: //g"'
        success, result = lib.shell.shell_exec(cmd)
        if success:
            birthday, _, _ = result
            birthday = birthday.strip()
    if birthday:
        return 'born {}. '.format(birthday)
    return ''


def get_boot_mode():
    return 'UEFI boot, ' if os.path.isdir('/sys/firmware/efi') else 'BIOS boot, '


def get_crontab():
    """Returns all crontab items.
    """
    cmd = r"grep --dereference-recursive --no-filename --invert-match '\s*#' /etc/crontab /etc/cron.d/ /etc/anacrontab /var/spool/cron" # pylint: disable=C0301
    success, result = lib.shell.shell_exec(cmd)
    if not success:
        return ''
    stdout, _, _ = result
    output = ''
    line_regex = re.compile(r'\S+=')
    for line in stdout.splitlines():
        line = line.strip()
        if len(line) > 0 and re.match(line_regex, line) is None:
            output = '{}{}\n'.format(output, line)
    if output:
        output = 'crontab:\n{}\n'.format(output)
    return output


def get_disks():
    """Returns system disks tuple "text, count": `'Disk nvme0n1 1.8T', 1`
    """
    success, result = lib.shell.shell_exec(
        'lsblk --nodeps --output NAME,SIZE --noheadings --include 8,252,259'
    )
    if not success:
        return '', 0
    stdout, _, _ = result
    output = []
    for disk in stdout.strip().splitlines():
        # zRAM devices can appear in the output of lsblk, but we cannot do anything useful with them
        if disk.startswith('zram'):
            continue
        output.append(re.sub('\\s+', ' ', disk))
    return '{} {}, '.format(
        lib.txt.pluralize('Disk', len(output)),
        ', '.join(output),
    ), len(output)


def get_hw_info():
    result = lib.dmidecode.get_data()
    output = ''
    for _, value in result.items():
        if value['dminame'] == 'Base Board Information':
            output += '* Base Board: Type {} {} {}, SerNo {}, Ver {}\n'.format(
                value.get('Type', 'n/a').replace('Default string', 'n/a'),
                value.get('Manufacturer', 'n/a').replace('Default string', 'n/a'),
                value.get('Product Name', 'n/a').replace('Default string', 'n/a'),
                value.get('Serial Number', 'n/a').replace('Default string', 'n/a'),
                value.get('Version', 'n/a').replace('Default string', 'n/a'),
            )
        if value['dminame'] == 'BIOS Information':
            output += '* BIOS: {}, Ver {} (released {}), ROM {}\n'.format(
                value.get('Vendor', 'n/a').replace('Default string', 'n/a'),
                value.get('Version', 'n/a').replace('Default string', 'n/a'),
                value.get('Release Date', 'n/a').replace('Default string', 'n/a'),
                value.get('ROM Size', 'n/a').replace('Default string', 'n/a'),
            )
        if value['dminame'] == 'Chassis Information':
            output += '* Chassis: {}, Type {}, SKU {}, SerNo {}\n'.format(
                value.get('Manufacturer', 'n/a').replace('Default string', 'n/a'),
                value.get('Type', 'n/a').replace('Default string', 'n/a'),
                value.get('SKU', 'n/a').replace('Default string', 'n/a'),
                value.get('Serial Number', 'n/a').replace('Default string', 'n/a'),
            )
            output += '  States: boot-up={}, pwr-supply={}, thermal={}, security={}\n'.format(
                value.get('Boot-up State', 'n/a').replace('Default string', 'n/a'),
                value.get('Power Supply State', 'n/a').replace('Default string', 'n/a'),
                value.get('Thermal State', 'n/a').replace('Default string', 'n/a'),
                value.get('Security Status', 'n/a').replace('Default string', 'n/a'),
            )
        if value['dminame'] == 'Processor Information':
            output += '* Proc: {}, Ver {},\n'.format(
                value.get('Manufacturer', 'n/a').replace('Default string', 'n/a'),
                value.get('Version', 'n/a').replace('Default string', 'n/a'),
            )
            output += '  Speed {}/{} max., {}/{} Cores enabled, {} {}, Voltage {}\n'.format(
                value.get('Current Speed', 'n/a').replace('Default string', 'n/a'),
                value.get('Max Speed', 'n/a').replace('Default string', 'n/a'),
                value.get('Core Enabled', 'n/a').replace('Default string', 'n/a'),
                value.get('Core Count', 'n/a').replace('Default string', 'n/a'),
                value.get('Thread Count', 'n/a').replace('Default string', 'n/a'),
                lib.txt.pluralize('Thread', value.get('Thread Count', 0)),
                value.get('Voltage', 'n/a').replace('Default string', 'n/a'),
            )
        if value['dminame'] == 'System Boot Information':
            output += '* System Boot: {}\n'.format(
                value.get('Status', 'n/a').replace('Default string', 'n/a'),
            )
        if value['dminame'] == 'System Information':
            output += '* SysInfo: {} {}, SerNo {}, SKU {}, Wake-up Type "{}",\n'.format(
                value.get('Manufacturer', 'n/a').replace('Default string', 'n/a'),
                value.get('Product Name', 'n/a').replace('Default string', 'n/a'),
                value.get('Serial Number', 'n/a').replace('Default string', 'n/a'),
                value.get('SKU', 'n/a').replace('Default string', 'n/a'),
                value.get('Wake-up Type', 'n/a').replace('Default string', 'n/a'),
            )
            output += '  UUID {}\n'.format(
                value.get('UUID', 'n/a').replace('Default string', 'n/a'),
            )
    if output:
        return 'Hardware Info:\n{}\n'.format(output)
    return output


def get_interfaces():
    output = ''
    try:
        for name, interface in sorted(psutil.net_if_addrs().items()):
            if name == 'lo':
                continue
            for addr in interface:
                if addr.family == lib.net.AF_INET:
                    output += '* {} {}/{}\n'.format(
                        name,
                        addr.address,
                        lib.net.ip_to_cidr(addr.netmask),
                    )
    except:
        pass
    if output:
        return 'Interfaces (IPv4):\n{}\n'.format(output)
    return output


def get_listening_ports():
    ports = {}
    output = []
    try:
        nc = psutil.net_connections('inet')
        for c in nc:
            if c.status != psutil.CONN_LISTEN and c.status != psutil.CONN_NONE:
                continue
            if c.type == socket.SOCK_STREAM:
                proto = 'tcp'
            elif c.type == socket.SOCK_DGRAM:
                proto = 'udp'
            else:
                continue
            if c.family == socket.AF_INET:
                proto += '4'
            else:
                proto += '6'
            ip, port = c.laddr
            ports['{}#{}#{}'.format(ip, port, proto)] = {
                'proto': proto,
                'ip': '[{}]'.format(ip) if c.family == socket.AF_INET6 and not ip.startswith('[') and not ip.endswith(']') else ip, # pylint: disable=C0301
                'port': port,
            }
        for _, value in ports.items():
            output.append(value)
        output = sorted(output, key=lambda d: (d['port'], d['proto'], d['ip']))
    except:
        pass
    if output:
        msg = 'Listening TCP/UDP Ports (ordered by port, proto, ip):\n'
        for p in output:
            msg += '* {}:{}/{}\n'.format(p['ip'], p['port'], p['proto'])
        msg += '\n'
        return msg
    return ''


def get_nondefault_software():
    success, result = lib.shell.shell_exec(
        'dnf repoquery --userinstalled --queryformat "%{name};%{version};%{from_repo};%{installtime}"' # pylint: disable=C0301
    )
    if not success:
        return ''
    stdout, _, _ = result
    table_data = []
    header = ['name', 'version', 'from_repo', 'installtime']
    for line in stdout.splitlines():
        data = dict(zip(header, line.split(';')))
        table_data.append(data)
    output = lib.base.get_table(
        table_data,
        header,
        header=header,
    )
    if output:
        return 'Non-default Software (ordered by name):\n{}\n'.format(output)
    return ''


def get_nondefault_users():
    default_linux_users = [
        '_apt',
        '_rpc',
        'abrt',
        'adm',
        'avahi',
        'backup',
        'bin',
        'chrony',
        'colord',
        'daemon',
        'dbus',
        'ftp',
        'games',
        'gnats',
        'halt',
        'irc',
        'list',
        'lp',
        'mail',
        'man',
        'messagebus',
        'news',
        'nobody',
        'operator',
        'pi',
        'polkitd',
        'proxy',
        'pulse',
        'rngd',
        'root',
        'rpc',
        'rpcuser',
        'shutdown',
        'sshd',
        'sssd',
        'sync',
        'sys',
        'systemd-coredump',
        'systemd-network',
        'systemd-oom',
        'systemd-resolve',
        'systemd-timesync',
        'tcpdump',
        'tss',
        'unbound',
        'user',
        'uucp',
    ]
    passwd = lib.base.coe(lib.disk.read_file('/etc/passwd'))
    table_data = []
    header = ['user', 'pw', 'uid', 'gid', 'comment', 'home_dir', 'user_shell']
    for line in passwd.splitlines():
        data = dict(zip(header, line.split(':')))
        if data['user'] not in default_linux_users:
            table_data.append(data)

    output = lib.base.get_table(
        table_data,
        header,
        header=header,
        sort_by_key='user',
    )
    if output:
        return 'Non-default Users:\n{}\n'.format(output)
    return ''


def get_public_ip(args):
    success, pub_ip = lib.net.get_public_ip(
        args.PUBLIC_IP_URL,
        insecure=args.INSECURE,
        no_proxy=args.NO_PROXY,
        timeout=args.TIMEOUT,
    )
    if success:
        return 'Public IP {}, '.format(pub_ip)
    return ''


def get_sys_dimensions():
    """get some very basic system statistics
    """
    sys_dimensions = {}
    try:
        sys_dimensions['cpu'] = psutil.cpu_count(logical=True)
        sys_dimensions['ram'] = psutil.virtual_memory().total
    except:
        pass
    return sys_dimensions


def get_systemd_default_target():
    cmd = 'systemctl get-default'
    success, result = lib.shell.shell_exec(cmd)
    if not success:
        return ''
    stdout, stderr, retc = result
    if stderr or retc != 0:
        return ''
    return 'systemctl get-default:\n* {}\n\n'.format(stdout.strip())


def get_systemd_timers():
    # using `--output=json` sadly does not work with older systemd versions
    # (eg systemd 219 on CentOS 7 or systemd 239 on RHEL 8), therefore we have to parse
    # the human output.
    # in order to list for a different user (`--user`), we would need to sudo to that user
    # first - we will skip that for now
    success, result = lib.shell.shell_exec('systemctl list-timers')
    if not success:
        return ''
    stdout, stderr, retc = result
    if stderr or retc != 0:
        return ''

    table_data = []
    next_pos = None
    left_pos = None
    unit_pos = None
    activates_pos = None
    for line in stdout.splitlines():
        if next_pos is None:
            # clutters a little bit on modern systemd (Fedora) because of right-aligned LEFT
            next_pos = line.find('NEXT')
            left_pos = line.find('LEFT')
            unit_pos = line.find('UNIT')
            activates_pos = line.find('ACTIVATES')
        if '.timer' in line:
            table_data.append({
                'unit': line[unit_pos:activates_pos].strip(),
                'activates': line[activates_pos:].strip(),
                'next': line[next_pos:left_pos].strip(),
            })

    output = lib.base.get_table(
        table_data,
        ['unit', 'activates', 'next'],
        header=['unit', 'activates', 'next'],
        sort_by_key='unit',
    )
    if output:
        return 'systemctl list-timers:\n{}\n'.format(output)
    return ''


def get_systemd_units(cmd):
    # using `--output=json` sadly does not work with older systemd versions
    # (eg systemd 219 on CentOS 7 or systemd 239 on RHEL 8), therefore we have to parse
    # the human output.
    # in order to list for a different user (`--user`), we would need to sudo to that user
    # first - we will skip that for now
    success, result = lib.shell.shell_exec(cmd)
    if not success:
        return ''
    stdout, stderr, retc = result
    if stderr or retc != 0:
        return ''
    if not stdout:
        return ''

    output = '{}:\n'.format(cmd.replace(' --no-legend', ''))
    for line in stdout.splitlines():
        output += '* {}\n'.format(line.split()[0])
    return output + '\n'


def get_lftags():
    lftags = [
        # {'sw': 'LF Tag Name', 'package': ['pname1', 'pname2'], 'expr': [stmnt1, stmnt2, ...]}, # pylint: disable=C0301
        {'sw': 'acme.sh', 'package': ['acme-tiny'], 'expr': [None]}, # pylint: disable=C0301
        {'sw': 'AIDE', 'package': ['aide'], 'expr': [os.path.isfile('/sbin/aide')]}, # pylint: disable=C0301
        {'sw': 'Apache httpd', 'package': ['httpd', 'apache2'], 'expr': [os.path.isfile('/usr/sbin/httpd')]}, # pylint: disable=C0301
        # {'sw': 'Apache Solr', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Axenita', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'BIND', 'package': ['bind'], 'expr': [os.path.isdir('/var/named')]}, # pylint: disable=C0301
        # {'sw': 'Bonding', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'BorgBackup', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Chronyd', 'package': ['chrony'], 'expr': [os.path.isfile('/etc/chrony.conf')]}, # pylint: disable=C0301
        {'sw': 'ClamAV', 'package': ['clamav'], 'expr': [None]}, # pylint: disable=C0301
        # {'sw': 'Collabora Online', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Composer', 'package': ['composer'], 'expr': [None]}, # pylint: disable=C0301
        # {'sw': 'coturn', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'DHCP Client', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Docker', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Duplicity', 'package': ['duplicity'], 'expr': [os.path.isfile('/usr/local/bin/duplicity')]}, # pylint: disable=C0301
        # {'sw': 'Elasticsearch', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Exim4', 'package': ['exim'], 'expr': [None]}, # pylint: disable=C0301
        {'sw': 'Fail2Ban', 'package': ['fail2ban'], 'expr': [os.path.isfile('/usr/bin/fail2ban-server')]}, # pylint: disable=C0301
        {'sw': 'FirewallD', 'package': ['firewalld'], 'expr': [None]}, # pylint: disable=C0301
        # {'sw': 'FortiOS 6', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'FreeIPA Server', 'package': ['ipa-server'], 'expr': [os.path.isfile('/usr/sbin/ipa-server-upgrade')]}, # pylint: disable=C0301
        {'sw': 'Fwbuilder', 'package': [], 'expr': [os.path.isfile('/etc/fwb.sh')]}, # pylint: disable=C0301
        {'sw': 'GitLab', 'package': ['gitlab-ce', 'gitlab-ee'], 'expr': [os.path.isdir('/opt/gitlab')]}, # pylint: disable=C0301
        # {'sw': 'Gluster Host', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Grafana', 'package': ['grafana'], 'expr': [os.path.isfile('/etc/grafana/grafana.ini')]}, # pylint: disable=C0301
        {'sw': 'Grav', 'package': [], 'expr': [os.path.isdir('/var/www/html/grav')]}, # pylint: disable=C0301
        {'sw': 'Graylog Server', 'package': ['graylog-server'], 'expr': [os.path.isfile('/etc/graylog/server/server.conf')]}, # pylint: disable=C0301
        # {'sw': 'H-Net eFaktura', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'HAProxy', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Huawei Dorado', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'InfluxDB', 'package': ['influxdb'], 'expr': [os.path.isfile('/etc/influxdb/influxdb.conf')]}, # pylint: disable=C0301
        # {'sw': 'Infomaniak Swiss Backup', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'IPMI', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'iSCSI', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Jitsi', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'JumpCloud Agent', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'KEMP', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Keycloak', 'package': ['todo'], 'expr': [os.path.isdir('/opt/keycloak'), os.path.isdir('/var/log/keycloak')]}, # pylint: disable=C0301
        # {'sw': 'KVM Host', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'LibreNMS', 'package': [], 'expr': [os.path.isdir('/opt/librenms')]}, # pylint: disable=C0301
        # {'sw': 'Logstash Client', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Logstash Server', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB Dump', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB InnoDB', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB Metrics', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB Replication', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB Schemas', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB Security', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MariaDB', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Matomo', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MediaWiki', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Metabase', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'mod_qos', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MongoDB', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'mydumper', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MySQL InnoDB', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MySQL Metrics', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MySQL Replication', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MySQL Schemas', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MySQL Security', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'MySQL', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Nextcloud', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'NFS Server', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Nginx', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'NodeBB', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'NTPd', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OnlyOffice', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'OpenVPN Server', 'package': ['openvpn'], 'expr': [os.path.isdir('/etc/openvpn')]}, # pylint: disable=C0301
        # {'sw': 'OS - Debian 8', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Debian 9', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Debian 10', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Debian 11', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Debian 12', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Fedora', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - RHEL 7', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - RHEL 8', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - RHEL 9', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Ubuntu 16', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Ubuntu 18', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Ubuntu 20', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'OS - Ubuntu 22', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'PHP', 'package': ['php'], 'expr': [None]}, # pylint: disable=C0301
        {'sw': 'PHP-FPM', 'package': ['php-fpm'], 'expr': [None]}, # pylint: disable=C0301
        {'sw': 'pip', 'package': ['python3-pip', 'python2-pip'], 'expr': [None]}, # pylint: disable=C0301
        {'sw': 'Postfix MTA', 'package': ['postfix'], 'expr': [os.path.isdir('/etc/postfix')]}, # pylint: disable=C0301
        # {'sw': 'PostgreSQL', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Proxmox', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'Python', 'package': ['python3', 'python2'], 'expr': [None]}, # pylint: disable=C0301
        # {'sw': 'QNAP QTS', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'RabbitMQ Server', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Redfish', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Redis', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'restic', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Rocket.Chat', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        {'sw': 'rsyncd', 'package': ['rsync'], 'expr': [None]}, # pylint: disable=C0301
        # {'sw': 'SafeNet HSM', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Samba', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'snmpd', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Splunk', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Starface PBX', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Statuspal', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'strongSwan IPSec', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'syslog-ng', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'system update', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Systemd Timesyncd', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Tarifpool v2', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'UPS (Network UPS Tools, nut)', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'vsftpd', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Wildfly', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'Wordpress', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
        # {'sw': 'XFS', 'package': ['todo'], 'expr': [os.path.isdir('todo')]}, # pylint: disable=C0301
    ]
    success, result = lib.shell.shell_exec('dnf repoquery --userinstalled --queryformat "%{name}"')
    if success:
        # for the moment focusing on rhel-compatible package managers
        userinstalled_software, _, _ = result
        userinstalled_software = userinstalled_software.splitlines()
    else:
        userinstalled_software = []

    output = ''
    for item in lftags:
        # if any of the listed software packages is installed, we have a match
        if any(i in item['package'] for i in userinstalled_software) \
        or any(item['expr']):
            output += '* {}\n'.format(item['sw'])
    if output:
        return 'Linuxfabrik\'s Icinga Director Tags:\n{}\n'.format(output)
    return ''


def get_tuned_active_profile():
    """ Return current active tuned profile (if any).
    """
    output = run_cmd('tuned-adm active')
    if output:
        return 'tuned profile "{}", '.format(run_regex(output, r': (.*)').strip().replace('* ', ''))
    return ''


def get_virt_info():
    # alternative would be `/usr/sbin/virt-what` (POSIX shell script)
    success, result = lib.shell.shell_exec('systemd-detect-virt')
    if success:
        stdout, _, _ = result
        return stdout.strip()
    return 'Unknown'


def run_cmd(cmd, ignore_output=False):
    """Run a command and return its output. Returns stderr if cmd prints its standard output there.
    If ignore_output is set to True, returns True. Returns False if cmd is not found.
    """
    env = os.environ.copy()
    env['LC_ALL'] = 'C'
    env['PATH'] += ':/usr/local/bin:/usr/local/sbin'
    success, result = lib.shell.shell_exec(cmd, env=env)
    if not success:
        return False
    stdout, stderr, retc = result
    if retc != 0:
        # for example if using `command -v loolwsd`
        return False
    if ignore_output:
        return True
    if stdout == '' and stderr != '':
        # https://stackoverflow.com/questions/26028416/why-does-python-print-version-info-to-stderr
        # https://stackoverflow.com/questions/13483443/why-does-java-version-go-to-stderr
        stdout = stderr
    try:
        return stdout.strip().splitlines()[0].strip()
    except IndexError:
        return True


def run_regex(haystack, regex, group=1):
    """Apply a regex to a haystack, assume first match group, otherwise let us choose which one.
    """
    re_search = re.search(regex, haystack)
    if re_search:
        return re_search.group(group).strip()
    return ''


def main():
    """The main function. Hier spielt die Musik.
    """

    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    # init some vars
    perfdata = ''
    tags = ''

    # only tags wanted, so it's ok to stop here
    if args.TAGS:
        lib.base.oao(tags, STATE_OK)

    # build the message

    # first header line ----------------------------------------------------------------------------
    msg = '{}: '.format(socket.gethostname())

    os_info = lib.version.get_os_info()
    if os_info:
        msg += '{} '.format(os_info)
    msg += 'Kernel {} '.format(run_cmd('uname -r'))

    virt = get_virt_info()
    if virt == 'none':
        msg += 'on Bare-Metal, '
    else:
        msg += 'virtualized on {}, '.format(virt)

    success, firmware_device_model = lib.disk.read_file('/sys/firmware/devicetree/base/model')
    if not success:
        firmware_device_model = ''
    if firmware_device_model:
        msg += '{}, '.format(firmware_device_model)

    dmi = lib.dmidecode.get_data()
    sys_dimensions = get_sys_dimensions()
    if dmi:
        msg += '{} {}, '.format(lib.dmidecode.manufacturer(dmi), lib.dmidecode.model(dmi))
        msg += 'Firmware: {}, '.format(lib.dmidecode.firmware(dmi))
        msg += 'SerNo: {}, '.format(lib.dmidecode.serno(dmi))
        msg += 'Proc: {}, '.format(lib.dmidecode.cpu_type(dmi))
        msg += '#Cores: {}, '.format(lib.dmidecode.cpu_cores_enabled(dmi))
        msg += '#Threads: {}, '.format(lib.dmidecode.cpu_threads(dmi))
        msg += 'Current Speed: {} MHz, '.format(lib.dmidecode.cpu_speed(dmi))
        msg += '{} RAM, '.format(lib.human.bytes2human(lib.dmidecode.ram(dmi)))
    elif sys_dimensions:
        msg += '{} {}, {} RAM, '.format(
            sys_dimensions['cpu'],
            lib.txt.pluralize('CPU', sys_dimensions['cpu']),
            lib.human.bytes2human(sys_dimensions['ram'])
        )
    else:
        msg += 'sys dimensions n/a (consider installing psutil), '

    disk_msg, disk_count = get_disks()
    msg += disk_msg
    msg += get_boot_mode()
    msg += get_tuned_active_profile()
    msg += get_public_ip(args)
    msg += get_birthday()
    msg += 'About-me v{}\n\n'.format(__version__)


    # multi-line content - print further lines -----------------------------------------------------
    msg += get_hw_info()
    msg += get_interfaces()
    msg += get_listening_ports()
    msg += get_nondefault_software()
    msg += get_nondefault_users()
    msg += get_systemd_default_target()
    msg += get_systemd_units(
        'systemctl list-unit-files --type=service --state=enabled --no-legend',
    )
    msg += get_systemd_units(
        'systemctl list-unit-files --type=mount --state=static --state=generated --no-legend',
    )
    msg += get_systemd_units(
        'systemctl list-unit-files --type=automount --state=enabled --state=static --no-legend',
    )
    msg += get_systemd_timers()
    msg += get_crontab()
    msg += get_lftags()

    # perfdata
    if os_info:
        re_search = re.search(r'[\d\.]+', os_info)
        if re_search:
            perfdata += lib.base.get_perfdata('osversion', re_search.group(0).replace('.', ''), None, None, None, None, None) # pylint: disable=C0301
    if dmi:
        perfdata += lib.base.get_perfdata('cpu_cores_enabled', lib.dmidecode.cpu_cores_enabled(dmi), None, None, None, 0, None) # pylint: disable=C0301
        perfdata += lib.base.get_perfdata('cpu_threads', lib.dmidecode.cpu_threads(dmi), None, None, None, 0, None) # pylint: disable=C0301
        perfdata += lib.base.get_perfdata('cpu_speed', lib.dmidecode.cpu_speed(dmi), None, None, None, 0, None) # pylint: disable=C0301
        perfdata += lib.base.get_perfdata('ram', lib.dmidecode.ram(dmi), 'B', None, None, 0, None)
    elif sys_dimensions:
        perfdata += lib.base.get_perfdata('cpu', sys_dimensions['cpu'], None, None, None, 0, None)
        perfdata += lib.base.get_perfdata('ram', sys_dimensions['ram'], 'B', None, None, 0, None)
    perfdata += lib.base.get_perfdata('disks', disk_count, None, None, None, 0, None)

    # over and out
    lib.base.oao(msg, STATE_OK, perfdata)


if __name__ == '__main__':
    try:
        main()
    except Exception:   # pylint: disable=W0703
        lib.base.cu()
